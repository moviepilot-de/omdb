# Copyright (c) 2007 Benjamin Krause, Jens Kraemer
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This is the ferret indexer, a custom indexer, supporting dependencies and
# globalize support. This is very project related and might not help you build
# your own ferret-indexer. Use acts_as_ferret instead.

require 'omdb_analyzer'
require 'fileutils'

module OMDB
  module Ferret
    class Indexer
      include ::Ferret
      include ::Ferret::Index
      include ::Ferret::Store
      include ::Ferret::Analysis

      @@iw = nil
      @@reindexing = false
      LOGGER = Logger.new("#{RAILS_ROOT}/log/indexer.log")

      @@index_root = nil
      
      # == Ferret Index Location
      #
      # The ferret index is located in "#{RAILS_ROOT}/db/ferret.index.#{RAILS_ENV}". To speed up 
      # test-cases, the test-index should be pregenerated using 'rake test_reindex'. If an index
      # is located in db/ferret.index.test/, that index will be load in a Ferret::Store::RAMDirectory
      # and used for testcases.
      # It will return the location for the index in all other environments
      def self.index_root( offline_index = false )
          @@index_root ||=  if RAILS_ENV == 'test' and File.exists?("#{self.online_index}/segments")
                            # clone on-disk index into ram
                            RAMDirectory.new( FSDirectory.new( offline_index ? self.offline_index : self.online_index ) )
                          else
                            FSDirectory.new( ( offline_index ? self.offline_index : self.online_index ) )
                          end
      end
      
      def self.online_index
        "#{RAILS_ROOT}/db/ferret.index.#{RAILS_ENV}.online"
      end
      
      def self.offline_index
        "#{RAILS_ROOT}/db/ferret.index.#{RAILS_ENV}.offline"
      end
      
      def self.online_index_storage_directory( index = 0 )
        "#{RAILS_ROOT}/db/ferret.index.#{RAILS_ENV}.#{index}"
      end
      
      def self.index_status_file
        "#{RAILS_ROOT}/db/ferret.index.#{RAILS_ENV}.last_switch"
      end
      
      # Automatically index ids of these relations of a movie. The ids are neccessary for the movie-filter.
      if not defined? MOVIE_FILTER_FIELDS
        MOVIE_FILTER_FIELDS = [ :category, :keyword, :person, :company, :country, :language ]
      end

     
      # == Ferret Indexing
      #
      # To index an object, use the index_object method. The method will decide whether to index
      # the object locally (is in test-env) or to pass it to the FerretServer.
      #
      # All indexing request will be generated by the SearchObserver.
      # 
      # The communication between the rails-application and the ferret server is based on hashes.
      # You should pass a ferret_index_hash to this method, not an AR-Object. You can use 
      # ActiveRecord::Base#to_hash_args to generate a valid hash.
      # 
      # >> Indexer.index_object Person.find(10).to_hash_args
      # => {:type=>"Person", :id=>10}
      def self.index_object( args )
        return unless args && args.size == 2
        if RAILS_ENV == 'test'
          get_writer do |writer|
            index_local( find_object(args), writer)
          end
        else
          index_remote args
        end
      end

      # Removes an object from the index. The object will be automatically removed
      # from the index before updating. The method will decide wheter to remove the
      # index locally from the index or to pass it to the FerretServer.
      def self.delete_object( args )
        return unless args && args.size == 2
        if RAILS_ENV == 'test'
          get_writer do |writer|
            delete_local( args, writer )
          end
        else
          delete_remote args
        end
      end
      
      # Index dependencies of an object. See ActiveRecord#db_depending_objects and
      # ActiveRecord#depending_objects in ar_base_ext for more detail about dependencies.
      # The depdencies 
      def self.index_dependencies(args)
        if RAILS_ENV == 'test'
          index_local_with_dependencies find_object(args)
        else
          index_remote_with_dependencies args
        end
      end


      # == Index Construction
      # 
      # Create a new, empty Ferret Index. See create_fields for more information about the
      # index structure. 
      def self.reset
        self.create_index self.index_root( true )
      end
      
      
      # == Index Bulk Operations
      #
      # Index all elements of a class, like reindexing all movies. Reindexing can take
      # a long time.
      #
      # >> Indexer.index_all Movie
      # => true
      def self.index_all( klass, writer = nil )
        if writer.nil?
          self.get_writer_and_optimize do |writer|
            klass.find_all.each do |o| self.index_local( o, writer ) end
          end
        else
          klass.find_all.each do |o| self.index_local( o, writer ) end
        end
        true
      end
      
      # Completely rebuild the Ferret-Index by creating a new index and indexing all
      # instances of all required AR-Classes. This will take a long time, use with care.
      def self.reindex( writer = nil )
        self.index_root
        @@reindexing = true
        begin
          if RAILS_ENV == 'test' && (@@index_root.nil? || RAMDirectory === @@index_root)
            @@iw = nil
            @@index_root.close if @@index_root
            @@index_root = nil
          else
            self.reset
            [ Movie, Person, Category, Company, Character, Job, Language, Country ].each { |klass|
              self.index_all klass, writer
            }
          end
        ensure
          @@reindexing = false
          true
        end
      end

      # Get the default index/search analyzer
      def self.get_analyzer
        @@analyzer ||= create_analyzer
      end

      # == Private indexing methods
      #
      # For each AR-Class whe have a indexing-method, so all indexing for a movie will
      # be done by the index_movie method.
      # 

      private


      # add element to the ferret index by creating a new Ferret::Document, add 
      # the standard-fields and call the class-dependent-indexing-method.
      def self.add_to_index( key, object, writer )
        benchmark("add_to_index #{key}") do
          method_name = "index_#{object.base_class_name.downcase}"
          if self.respond_to?(method_name)
            doc             = Document.new( self.get_boost_value(object) )
            doc[:id]        = key                        # ferret-id (used to remove from the index)
            doc[:object_id] = object.id                  # database-id
            doc[:name]      = object.name                # all classes respond to :name
            doc[:type]      = object.base_class_name.downcase
            doc[:keywords]  = []
            LOCALES.each_key { |key| doc["keywords_#{key}".to_sym] = [] }

            self.send(method_name, doc, object)

            writer << doc
          end
        end
      end
      
      # may be called with an instance, or with a hash having :class and :id, with
      # class being a class name or the class itself
      def self.index_key( args )
        return args if String === args # is already a key
        clazz, id = case args
                      when Hash
                        args[:class] = args[:class].constantize if String === args[:class]
                        [args[:class], args[:id]]
                      else
                        # assume it's an AR object
                        [args.class, args.id]
                      end
        "#{clazz.base_class_name.downcase}_#{id}"
      end

      # :TODO: is this really neccessary? We need to further investigage
      # the backgroundrb behaviour to drop this sleeping.. 
      def self.wait_a_bit
        sleep 0.05 unless @@reindexing
      end

      # === Index Categories
      # 
      # Index Category-Objects (like Plot Keywords, Genres, etc.)
      def self.index_category( doc, object )
        self.index_hierarchy doc, object
        wait_a_bit
        self.index_assignable doc, object
        self.index_aliases doc, object
        wait_a_bit
        self.index_contents doc, object
      end


      # === Index Characters
      #
      # Index characters (like Indiana Jones, Darth Vader, Duffy Duck, etc.)
      def self.index_character( doc, object )
        self.index_popularity doc, object
        self.index_aliases doc, object
        wait_a_bit
        self.index_contents doc, object
      end


      # === Index Companies
      # 
      # Index companies 
      def self.index_company( doc, object )
        self.index_popularity doc, object
        self.index_aliases doc, object
        wait_a_bit
        self.index_contents doc, object
      end


      # === Index Countries
      #
      # Index countries
      def self.index_country( doc, object )
        self.index_aliases doc, object
        self.index_globalize_translations doc, object
      end


      # === Index Jobs
      #
      # Index jobs (like Director, Executive Producer, etc.)
      def self.index_job(doc, object)
        self.index_parent doc, object
        self.index_aliases doc, object
        wait_a_bit
        self.index_popularity doc, object
        self.index_contents doc, object
        self.index_department doc, object
      end


      # === Index Languages
      #
      # Index languages
      def self.index_language( doc, object )
        self.index_globalize_translations doc, object
      end


      # === Index Movies
      # 
      # Index Movie-Objects (like Movies, MovieSeries, Episodes, etc.). See MOVIE_FILTER_FIELDS
      def self.index_movie( doc, object )
        self.index_ids doc, object, MOVIE_FILTER_FIELDS
        self.index_popularity doc, object
        wait_a_bit
        self.index_contents doc, object
        self.index_aliases doc, object
        wait_a_bit
        self.index_parent doc, object
        self.index_movie_type doc, object
        wait_a_bit
        self.index_movie_categories doc, object
        self.index_cast doc, object
        wait_a_bit
        self.index_rating doc, object
      end


      # === Index People
      # 
      # Index people
      def self.index_person( doc, object )
        self.index_popularity doc, object
        self.index_aliases doc, object
        wait_a_bit
        self.index_contents doc, object
        self.index_movies doc, object
      end


      # == Index-Fields
      #
      # Index special fields of each object.

      # The boost value is responsible for the ranking of this object in searching-results.
      # The higher the boost value, the better the ranking. Boost values in omdb are bound
      # to the popularity of an object. The higher the popularity the better the boost value.
      # see CalculatePopularity for more details.
      # The boost value is 1/10 of the popularity of an object.
      def self.get_boost_value( object )
        object.respond_to?(:popularity) ? object.popularity.to_f * 0.1 + 0.1 : 1.0
      end

      # Index the popularity of the object. This is neccessary for sorting objects by popularity
      def self.index_popularity( doc, object )
        doc[:popularity] = object.popularity
      end

      # Index the categories of a movie (its genres, keywords, etc.). Each keywords will be index
      # for all languages. If you assign a keyword to a movie, the movie will be automatically
      # be found if searched for the keyword. 
      # see MovieUserCategoryFerretTest for some examples.
      def self.index_movie_categories( doc, object )
        [ "categories", "keywords" ].each do |method|
          object.send(method).each do |c|
            c.alias_names_by_language.each do |lang_code, names|
              next unless LOCALES.keys.include?(lang_code)
              doc["keywords_#{lang_code}".to_sym] << names.join(" ")
            end
          end
        end
      end

      # Index the wiki-content of an object. any omdb-object can have several localized contents.
      # We'll just merge them all and add them into the content_#{lang} field.
      def self.index_contents( doc, object )
        object.contents_by_language.each do |language_code, contents|
          data = contents.collect{ |c| c.data }.join(" ") unless contents.nil?
          doc["content_#{language_code}".to_sym] = data
        end
      end

      # Index all aliases (local names and synonyms) of an object.
      def self.index_aliases( doc, object )
        if object.respond_to?(:alias_names_by_language)
          object.alias_names_by_language.each do |lang_code, names|
            # :TODO: This needs to be more granular, simply taking the first
            # alias is not always right.. 
            doc["name_#{lang_code}".to_sym] = names.first;
            doc["aliases_#{lang_code}".to_sym] = names.join(" ").downcase
          end
        elsif object.respond_to?(:aliases)
          aliases = object.aliases.collect { |a| a.name }.join(" ")
          aliases << " " + object.name.gsub(/-/, " ") if object.respond_to?(:name)
          doc[:aliases] = aliases
        end
      end

      # Index globalize-translations. The country and language names in each language
      # are part of the globalize translation table. We'll fetch the translation from
      # globalize, using globalize's own Locale#translator method.
      def self.index_globalize_translations( doc, object )
        LOCALES.keys.each do |code|
          doc["name_#{code}".to_sym] = Locale.translator.fetch( object.name, Language.pick(code) )
        end
      end

      # Index the type of of the movie (like MovieSeries, Episode or simply Movie).
      def self.index_movie_type( doc, object )
        doc[:movie_type] = object.class.to_s.demodulize.underscore
      end

      # Index the parent of the object. This is neccessary for the assign-children interface
      # for movies. The search will only find objects, that are not yet assigned to a parent.
      # Like if you want to add movies to a MovieSeries, you don't want to find all movies
      # that are already part of a series.
      def self.index_parent( doc, object )
        doc[:parent] = object.has_parent?.to_s
      end

      # Index department of a job. This is neccessary to allow to search for jobs of a special
      # department. We'll furthermore set :is_department to 1 because most of the time we just
      # want to find jobs, but not departments (like on the add_cast/add_crew dialogs).
      def self.index_department( doc, object )
        doc[:department_id] = object.department.id
        doc[:is_department] = 1 if object.class == Department
      end

      # Index the names of the 10 most important actors/authors/etc. of a movie as part of the
      # movie. So if you search for the name of an actor, you'll also find his/her movies.
      def self.index_cast( doc, object )
        Job::IMPORTANT_JOBS.keys.collect.each do |method|
          object.send(method.to_s.pluralize).slice(0,10).each do |c|
            doc[:keywords].push( c.person.name )
            doc[:keywords].push( c.comment ) unless c.comment.nil? or c.comment.empty?
            doc[:keywords].push( c.character.name ) if object.class == Actor and not c.character.nil?
          end
        end
      end

      # Index the most popular movies of a person, so if you search for a person, you'll also
      # find some of his/her movies.
      def self.index_movies( doc, object )
        object.popular_movies.slice(0,5).each do |movie|
          movie.alias_names_by_language.each do |lang_code, names|
            next unless LOCALES.keys.include?(lang_code)
            doc["keywords_#{lang_code}".to_sym] << names.slice(0,2).join(" ")
          end
        end
      end

      # Index the hierarchy for movies and categories. neccessary for the edit-category dialogs.
      def self.index_hierarchy( doc, object )
        LOCALES.keys.each do |key|
          doc["hierarchy_#{key}".to_sym] =  object.flattened_name( Language.pick(key) )
          object.categories_from_root.each do |cat|
            doc["keywords_#{key}".to_sym] << cat.local_name( Language.pick(key) )
          end
        end
        doc[:root_id]    = object.root.id
        doc[:is_keyword] = 1 if object.root.id == Category.plot_keyword.id
      end

      # Index the is-assignable flag for categories. non-assignable categories exists for
      # structural purposes and are not assignable to movies.
      def self.index_assignable( doc, object )
        doc[:is_assignable] = (object.respond_to?(:assignable) && object.assignable) ? 1 : 0
      end

      # Index the rating of a movie.
      def self.index_rating( doc, object )
        doc[:rating] = object.vote
      end

      # Index all relation-ids of a movie
      def self.index_ids( doc, object, fields )
        fields.each do |field|
          field = field.to_s
          doc[(field + '_ids').to_sym] =
            object.send(field.pluralize.to_sym).map { |o|
              if o.respond_to?(:objects_to_root)
                o.objects_to_root.collect{|i| i.id}
              else
                o.id
              end
            }.flatten.uniq
        end
      end


      # == Local Indexing 
      # 
      # The real indexing methods, modifying the local ferret index. 

      # Index an AR-Object.
      def self.index_local( object, writer )
        return if object.nil?
        return self.index_local( object.movie, writer ) if object.class == Actor

        if object.class == MovieUserCategory
          # self.index_local object.category
          return self.index_local( object.movie, writer )
        end
        key = index_key( object )
        # Ferret does not allow us to change data once it is in the index, 
        # so we need to delete the document and re-add it.
        delete_local( key, writer ) unless @@reindexing
        add_to_index( key, object, writer )
      end


      def self.index_local_with_dependencies(record)
        LOGGER.info "indexing dependencies of #{record}"
        objects = record.dependent_objects
        objects.each do |class_name, id_array|
          id_array.each do |id|
            next if id == 0
            get_writer do |writer|
              index_local find_object( :type => class_name, :id => id ), writer
            end
          end
        end
      end

      # Delete object from ferret index.
      def self.delete_local( args, writer )
        key = String === args ? args : index_key(:class => args[:type], :id => args[:id])
        writer.delete(:id, key)
      end
  

      ##################
      # remote indexing 
      ##################
  
      def self.remote_indexer
        MiddleMan.get_worker 'ferret_server'
      end
  

      def self.index_remote( args )
        remote_indexer << args
      end

      def self.delete_remote( args )
        remote_indexer - args
      end
  
      def self.index_remote_with_dependencies(args)
        remote_indexer.index_dependencies args
      end

      def self.find_object(args)
        clazz = args[:type].constantize
        clazz.find args[:id]
      rescue
        LOGGER.warn "error retrieving object for args #{args.inspect}:\n#{$!}"
        raise $!
      end

      def self.open_writer( offline_index = false )
        options = {
          :max_buffer_memory   => 0x6000000,
          :merge_factor        => 16,
          :term_index_interval => 64,
          :doc_skip_interval   => 8,
          :max_buffered_docs   => 128000,
          :field_infos         => self.create_fields,
          :use_compound_file   => true,
          :analyzer            => get_analyzer,
          :dir                 => self.index_root( offline_index )
        }
        begin 
          @@iw = IndexWriter.new options
        rescue => e
          # wait for whatever is blocking the indexer
          LOGGER.info "Something went wrong while waiting for the index lock.. "
          LOGGER.info e.backtrace.join("\n")
          sleep 5
          @@iw = IndexWriter.new options
        end
        @@iw
      end

      def self.get_writer( offline = false )
        if @@iw
          yield @@iw
        else
          begin
            @@iw = open_writer( offline )
            yield @@iw
          ensure
            @@iw.close if @@iw
            @@iw = nil
          end
        end
      end

      def self.get_writer_and_optimize( offline = false )
        if @@iw
          yield @@iw if block_given?
        else
          begin
            @@iw = open_writer( offline )
            yield @@iw if block_given?
            @@iw.optimize
          ensure
            @@iw.close if @@iw
            @@iw = nil
          end
        end
      end

      # == Index Creation
      # 
      # The Ferret index consists of several field. The fields are:
      # 

      # create a new local index
      def self.create_index(root = self.index_root)
        self.create_fields.create_index(root)
      end

      # Default values for ferret fields.
      # - Don't store the value of the field (keeping the index small, and we're
      #   going to fetch the data from the db anyway - see OmdbLazyDoc for more)
      # - Index the value untokenized (will be changed for content fields)
      # - Don't store a term vector (this is useful for search text highlighting, what
      #   we won't do.)
      def self.create_field_infos
        FieldInfos.new( :store       => :no,
                        :index       => :untokenized,
                        :term_vector => :no )
      end

      # Optimize the Index. This will be done whenever the Index-Queue is empty. Optimizing
      # is needed to speed up searches, but it will take a long time, so we should do it 
      # periodically but rarely.
      def self.optimize
        get_writer_and_optimize
      end

      # == Ferret Structure
      #
      # This defines all fields for the ferret index. There're basically two types of fields, data-fields (see create_data_field)
      # to store database-content in the ferret index, and searchable-fields (see create_searchable_field), that will be indexed
      # and tokenized, but its content will not be stored in the ferret index, hence these data needs to be fetched from the database
      # when accessed.
      #
      # Some of the fields are language dependent, these fields have an language-code suffix like 'name_de' or 'name_en'.
      def self.create_fields
        field_infos = self.create_field_infos
        self.create_data_field field_infos,    :id,            0.1  # internal ferret-id
        self.create_data_field field_infos,    :object_id,     0.1  # db-id
        self.create_data_field field_infos,    :type,          1.0  # object-class
        self.create_data_field field_infos,    :category_type, 0.1  # category-type like genre, audience, etc. (id)
        self.create_data_field field_infos,    :movie_type,    1.0  # movie-type like Series
        self.create_data_field field_infos,    :department_id, 1.0  # Department of Jobs
        self.create_data_field field_infos,    :is_department, 0.1  # is this a Department or a Job 
        self.create_data_field field_infos,    :is_keyword,    0.1  # is this a PlotKeyword or a Category 
        self.create_data_field field_infos,    :is_assignable, 0.0  # can this Category be assigned to a movie 
        self.create_data_field field_infos,    :rating,        0.1  # Rating of a movie
        self.create_data_field field_infos,    :parent,        0.0  # has this object a parent
        self.create_data_field field_infos,    :popularity,    0.0  # important for sorting
        self.create_data_field field_infos,    :name,          10.0, :index => :yes # Name of ppl, company, movie, etc.
        self.create_data_field field_infos,    :root_id,       0.0  # id of the root element of this object
        self.create_searchable_field field_infos, :aliases,       7.5  # Aliases of ppl, company
        self.create_searchable_field field_infos, :keywords,      3.0  # General Keywords (like actor names)
        LOCALES.each_key do |key|
          self.create_data_field field_infos,          "name_#{key}".to_sym, 5.0, :index => :yes # Store the local name of an object
          self.create_data_field field_infos,          "hierarchy_#{key}".to_sym, 1.5, :index => :untokenized # Store the hierarchy of categories
          self.create_searchable_field field_infos,    "content_#{key}".to_sym, 1.0 # language-dependent wiki-content
          self.create_searchable_field field_infos,    "aliases_#{key}".to_sym, 5.0 # language-dependent aliases
          self.create_searchable_field field_infos,    "keywords_#{key}".to_sym, 2.0 # language-dependent keywords
        end
        MOVIE_FILTER_FIELDS.each do |key|
          self.create_data_field field_infos, "#{key}_ids".to_sym, 0.1
        end
        field_infos
      end
      
      def self.create_analyzer
        @@analyzer = PerFieldAnalyzer.new( OmdbDefaultAnalyzer.new )
        LOCALES.each_key do |key|
          language = Language.pick(key)
          @@analyzer["content_#{key}".to_sym] = OmdbContentAnalyzer.new( language )
          @@analyzer["keywords_#{key}".to_sym] = OmdbContentAnalyzer.new( language )
        end
        @@analyzer
      end
      
      # Create a searchable field, that will get indexed and tokenized but will not be stored in the index.
      #
      # Example:
      #  self.create_searchable_field( field_infos, :keywords, 3.0 )
      #
      def self.create_searchable_field( field_infos, name, boost, options = {} )
        opts = { :index => :yes, :boost => boost }.merge( options )
        field_infos.add_field( name, opts )
      end

      # Create a data fields, that get indexed and tokenized and will be stored in the index, so they
      # can be accessed directly from the ferret index. Its important to store all content for live-searches
      # in the ferret index, as it can be much faster retrieved then database content. See OmdbLazyDoc.
      # 
      # Example:
      #  self.create_data_field( field_infos, :name, 10.0 )
      #
      def self.create_data_field( field_infos, name, boost, options = {} ) 
        opts = { :store => :compressed, :boost => boost }.merge( options )
        field_infos.add_field( name, opts )
      end
      
      def self.create_directory_structure
        mkdir self.online_index_storage_directory(0) unless File.exists? self.online_index_storage_directory(0)
        mkdir self.online_index_storage_directory(1) unless File.exists? self.online_index_storage_directory(1)
        ln_s self.online_index_storage_directory(0), self.online_index unless File.exists? self.online_index
        ln_s self.online_index_storage_directory(1), self.offline_index unless File.exists? self.offline_index
        touch self.index_status_file unless File.exists? self.index_status_file
      end

      # Helper method to gather some statistics about indexing
      def self.benchmark(name)
        t = Time.now
        yield
        LOGGER.info "#{name} took #{Time.now - t} seconds"
      end

    end
  end
end
